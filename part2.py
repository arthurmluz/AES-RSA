# Arthur Musskopf da Luz - PARTE 2
# README.md contém todos os valores obtidos/utilizados nas 2 partes

from hashlib import sha256
from Crypto.Util.Padding import pad, unpad
from Crypto.Cipher import AES

def hexPrint(val):
   return str(hex(val))[2:].upper()

# valores fixos obtidos do professor
e_professor = int('2E76A0094D4CEE0AC516CA162973C895', 16)
N_professor = int('1985008F25A025097712D26B5A322982B6EBAFA5826B6EDA3B91F78B7BD63981382581218D33A9983E4E14D4B26113AA2A83BBCCFDE24310AEE3362B6100D06CC1EA429018A0FF3614C077F59DE55AADF449AF01E42ED6545127DC1A97954B89729249C6060BA4BD3A59490839072929C0304B2D7CBBA368AEBC4878A6F0DA3FE58CECDA638A506C723BDCBAB8C355F83C0839BF1457A3B6B89307D672BBF530C93F022E693116FE4A5703A665C6010B5192F6D1FAB64B5795876B2164C86ABD7650AEDAF5B6AFCAC0438437BB3BDF5399D80F8D9963B5414EAFBFA1AA2DD0D24988ACECA8D50047E5A78082295A987369A67D3E54FFB7996CBE2C5EAD794391', 16)

# valores obtidos na parte 1
d_a = int('5F3BCD861338FEEE97026F9DC974CD70F078981AFD210DE96A430A1F3E9CF2D32593641EF1A9A6D025121FE6C802DFDE3007ED607BFAF1DF1D74D6554B52C6193B4DCC6CEC2F82EEF962BA72EDCF74FBF986DCA1242EB602FBA2C6860FE7125553CF59F425B8B6542740CDE8F242EF33526ABBEA5D6C5975E0DDB0B19F52C036593D3084D9A0EFFE9633C2DB8640C2AF914F41406C54D05A7614C51B6426CC1CB127C9BCB53344915D0107E836A0D1FD2221F7CDC317E30076EB918EB77E73FDFD485D535633F8E460A08AB6E65FCF472B47882D8E114F1B8FFD9C9683FA706BA25B1BFEB3F43C5C60A6A98AE12CEDE7DD8DE282C46E14AC3782ECEBFF1B1323', 16) # minha chave secreta
s = '00E621977578D75D3992C9A0B988A42F'
N_a = int('64910929F05B40EB213E6294D0777EA107D78A8DE8849C35ED1C2D4796344ABC6DAB3ED4B5046202F9C3E8B6A0D567C94C89E8419672BAE03AC67F4AE67D77B4D4B7374760CE7C7348072A3390560806C188DC46F4105AFD9E794239A890713A03A0BB812FCFF7B9E2DFCD02D6F7F1683CED1DF6B980AE4237871A160B8235E495ADBFFF7564F946967E8BA063F29D6862CCAA04F1F34AFFC4506DD037FBC1C6541F7759E1E714E8D93C55FD78E9525FE6D2FF0425C2434B6CC0C27FA59FDEBA9672E2B6DFE3EA56C2CECBBB6B22FCA06704E2CEBD70A223936F36C143426A1553BC4CD445FF4F71761A3953A71527A4CC3283C7A7F859A3AD8CC81FF6A7561D', 16)

# Mensagem cifrada e assinatura passados pelo professor:
msg_cifrada = 'F3B800F5FC9F7711BA76A3B186871F36CE6A37BDD8C9135B0DEE7A8BEAF3D7AF4A3AC4CABE7C5F54DEDE59F108E51B793464F436F8384595704F9C89A8194997105E2244AF75722A8BDB7326DE32E9A7'
sig_c = int('02B1D51CFA1C7DF3A2533F73618B935D02F90FF95663E60C7A5DE65172BE9E5BB435C9262B86715B6580150B82938C02110630C177BB8F7ED531B4DC279BCF9069A9B207A11FABB473D78FA1DB55CD71A34EE799570C8D3E17EF23E94B56C0565387226EFD2B0F1DB1FB2C88D515E5ED9A5D008B74CF43A54AC408E3D58D437017AA724DB484F4BA0A79A34A94A55F3A32B796A90F82CC662DC53CEF513DFCFB704759ABBA0BBE3C1C74AEA5AED20060A97A40A8136A88C6BA802F512372C916ADC577C4EE16D5CB7B71C1345FBF56A57D38C2DD3E6761185A85549CCB2E1F17E2B786E8BD1D13E54B02A797DD6CFEF3246D08A8E0CBE45B8A7071EFD8643100', 16)

# Caso queira testar enviando valores para o programa:
#msg_cifrada = input('Mensagem cifrada: ') 
#sig_c =  int(input('sig_c = '), 16)

# calculo da hash256 da mensagem
h256 = sha256()
h256.update(bytes.fromhex(msg_cifrada)) 
hash_c = int(h256.hexdigest(), 16)

# verificar assinatura da mensagem
if not (hash_c == pow(sig_c, e_professor, N_professor)): 
    print("ERRO DE ASSINATURA!!")
    exit()

# descriptografar mensagem AES CBC
key = bytes.fromhex(s)
iv  = bytes.fromhex(msg_cifrada[:32])
msg_c = bytes.fromhex(msg_cifrada[32:])

aes = AES.new(key, AES.MODE_CBC, iv)
m = aes.decrypt(msg_c)
m = unpad(m, AES.block_size) # remoção de padding caso tenha
m = m.decode('utf-8')        
print("\nmensagem decodificada:", m)

m_inv = m[::-1] # inverter a mensagem decodificada 
#print(m_inv.encode('utf-8'))

# Geração do IV aleatorio, comentada para ter um único a fins de debug
#iv_aleatorio = number.getRandomNBitInteger(128)
#iv_aleatorio = hexPrint(iv_aleatorio) 

iv_aleatorio = 'FB0A4212E1B8C4C59B255300C2C13006' # mantive IV fixo para poder repetir resultados
print("\niv_aleatorio =", iv_aleatorio)
iv_aleatorio = bytes.fromhex(iv_aleatorio)

# Encriptografar a mensagem
aes_encrypt = AES.new(key, AES.MODE_CBC, iv_aleatorio)   # inicializa o AES
pad_m_inv = (pad(m_inv.encode('utf-8'), AES.block_size)) # adição de padding
c_inv = aes_encrypt.encrypt(pad_m_inv)                   # encriptografa a mensagem
c_inv = str(iv_aleatorio.hex()) + str(c_inv.hex())       # concatena IV + msg criptografada

# calcula o sha256 da mensagem criptografada
h256 = sha256()
h256.update(bytes.fromhex(c_inv))
h_inv = h256.hexdigest()
h_inv = int(h_inv, 16)

sig_h_inv = pow(h_inv, d_a, N_a) # Assina a mensagem com minha chave
print("\nc_inv =", c_inv.upper())
print("\nsig_h_inv =", hexPrint(sig_h_inv))