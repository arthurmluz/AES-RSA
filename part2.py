# Arthur Musskopf da Luz - PARTE 2
# README.md contém todos os valores obtidos/utilizados nas 2 partes

from hashlib import sha256
from Crypto.Util.Padding import pad, unpad
from Crypto.Cipher import AES

def hexPrint(val):
   return str(hex(val))[2:].upper()

# valores fixos obtidos do professor
e_professor = int('2E76A0094D4CEE0AC516CA162973C895', 16)
N_professor = int('1985008F25A025097712D26B5A322982B6EBAFA5826B6EDA3B91F78B7BD63981382581218D33A9983E4E14D4B26113AA2A83BBCCFDE24310AEE3362B6100D06CC1EA429018A0FF3614C077F59DE55AADF449AF01E42ED6545127DC1A97954B89729249C6060BA4BD3A59490839072929C0304B2D7CBBA368AEBC4878A6F0DA3FE58CECDA638A506C723BDCBAB8C355F83C0839BF1457A3B6B89307D672BBF530C93F022E693116FE4A5703A665C6010B5192F6D1FAB64B5795876B2164C86ABD7650AEDAF5B6AFCAC0438437BB3BDF5399D80F8D9963B5414EAFBFA1AA2DD0D24988ACECA8D50047E5A78082295A987369A67D3E54FFB7996CBE2C5EAD794391', 16)

# valores obtidos na parte 1
d_a = int('5F3BCD861338FEEE97026F9DC974CD70F078981AFD210DE96A430A1F3E9CF2D32593641EF1A9A6D025121FE6C802DFDE3007ED607BFAF1DF1D74D6554B52C6193B4DCC6CEC2F82EEF962BA72EDCF74FBF986DCA1242EB602FBA2C6860FE7125553CF59F425B8B6542740CDE8F242EF33526ABBEA5D6C5975E0DDB0B19F52C036593D3084D9A0EFFE9633C2DB8640C2AF914F41406C54D05A7614C51B6426CC1CB127C9BCB53344915D0107E836A0D1FD2221F7CDC317E30076EB918EB77E73FDFD485D535633F8E460A08AB6E65FCF472B47882D8E114F1B8FFD9C9683FA706BA25B1BFEB3F43C5C60A6A98AE12CEDE7DD8DE282C46E14AC3782ECEBFF1B1323', 16) # minha chave secreta
s = '00E621977578D75D3992C9A0B988A42F'
N_a = int('64910929F05B40EB213E6294D0777EA107D78A8DE8849C35ED1C2D4796344ABC6DAB3ED4B5046202F9C3E8B6A0D567C94C89E8419672BAE03AC67F4AE67D77B4D4B7374760CE7C7348072A3390560806C188DC46F4105AFD9E794239A890713A03A0BB812FCFF7B9E2DFCD02D6F7F1683CED1DF6B980AE4237871A160B8235E495ADBFFF7564F946967E8BA063F29D6862CCAA04F1F34AFFC4506DD037FBC1C6541F7759E1E714E8D93C55FD78E9525FE6D2FF0425C2434B6CC0C27FA59FDEBA9672E2B6DFE3EA56C2CECBBB6B22FCA06704E2CEBD70A223936F36C143426A1553BC4CD445FF4F71761A3953A71527A4CC3283C7A7F859A3AD8CC81FF6A7561D', 16)

# Mensagem cifrada e assinatura passados pelo professor:
msg_cifrada = 'F62E9DE75607A205D4046DD551C7446FA8D5CEA7FC64A879A8AE286D546B479164302E0E14E56CAE8246B87647BEE5D4ABDE7B7BB69CA0EEC354895C40499601E6A0223B948BAA2E62CE9F6DD78BE599'
sig_c = int('07A3689DDB08C8423A0AE7E1221CDE6DB84FAFB4FADAEF1110797247E2100F046F27096BBDB027EB307B36013A089218A4B6336149CD23205F490ADEEF4EB82AEED4BDF0CE72B152BB63C92BE6DEAAF8AFEDCCBE8B30266592BC94961326F278534334B2B105D7ED0E27F750318C54F2EA258ECA917BAD0B5A5E24941BA3FF6CBEF80C89BB26BBFA4C7F191C199B7EE0A32F863E149B4E5C39D97DA3D3A7DC314A01F438885CD6130A583277D7167A6B27189FBC963176486F11D3B3C8CBD32F90ABEEDC03646571F6D2990A793EA507B0F9EEDD431ADB6CB578FC217F511C248EBBA4C34C658F62846477DC505868F386D36FB4E14C2920B9213F1C2CB16FDD', 16)

# segunda mensagem enviada
#msg_cifrada = '0005051D5A8A066970D13786984579CF6BA279DDED0B234A431A7103A1A85B419DA8FDB746CC1585090B0AAA5122E850A0A7BCB0606CB148D4850432825E6A4D'
#sig_c = int('153E6969F4816E81AFCEBC2B6E5771B70C79FA3397138AE71FDF3520E3F7856F10B83AD5DF39A2C6F8ADC131A3C10E0048939CA0B4B358779E1B7DF2EC2D7D1AA603A2515D53E4B2CBFD1486C952DF4117D3241E87048CBF2B38B1A0AAEFC04627F55BA4CD4382666E3CBA00EA9D4E6B3ECE7B68DA1BB8E5BE5C3E4CF7054B9F44F18FE6BE730CD9B3F19BCDBF9D8C594B7D970A44A8122F265948B56F107031F8B80973469CE7CF7F85008176947B9C7B22272269EAF55AC23BA8FD1E253B648E022BDEA0564B1E7548ED0635EBF564D83A39A27AE28BA12DCBC1EF8F60F3EFB3255A8BB05CCE66986FE7A0C93EF58DE92D5E51D8CEF2B499C0D3D6748B96D2', 16)

# Caso queira testar enviando valores para o programa:
#msg_cifrada = input('Mensagem cifrada: ') 
#sig_c =  int(input('sig_c = '), 16)

# calculo da hash256 da mensagem
h256 = sha256()
h256.update(bytes.fromhex(msg_cifrada)) 
hash_c = int(h256.hexdigest(), 16)

# verificar assinatura da mensagem
if not (hash_c == pow(sig_c, e_professor, N_professor)): 
    print("ERRO DE ASSINATURA!!")
    exit()

# descriptografar mensagem AES CBC
key = bytes.fromhex(s)
iv  = bytes.fromhex(msg_cifrada[:32])
msg_c = bytes.fromhex(msg_cifrada[32:])

aes = AES.new(key, AES.MODE_CBC, iv)
m = aes.decrypt(msg_c)
m = unpad(m, AES.block_size) # remoção de padding caso tenha
m = m.decode('utf-8')        
print("\nmensagem decodificada:", m)

m_inv = m[::-1] # inverter a mensagem decodificada 
#print(m_inv.encode('utf-8'))

# Geração do IV aleatorio, comentada para ter um único a fins de debug
#iv_aleatorio = number.getRandomNBitInteger(128)
#iv_aleatorio = hexPrint(iv_aleatorio) 

iv_aleatorio = 'FB0A4212E1B8C4C59B255300C2C13006' # mantive IV fixo para poder repetir resultados
print("\niv_aleatorio =", iv_aleatorio)
iv_aleatorio = bytes.fromhex(iv_aleatorio)

# Encriptografar a mensagem
aes_encrypt = AES.new(key, AES.MODE_CBC, iv_aleatorio)   # inicializa o AES
pad_m_inv = (pad(m_inv.encode('utf-8'), AES.block_size)) # adição de padding
c_inv = aes_encrypt.encrypt(pad_m_inv)                   # encriptografa a mensagem
c_inv = str(iv_aleatorio.hex()) + str(c_inv.hex())       # concatena IV + msg criptografada

# calcula o sha256 da mensagem criptografada
h256 = sha256()
h256.update(bytes.fromhex(c_inv))
h_inv = h256.hexdigest()
h_inv = int(h_inv, 16)

sig_h_inv = pow(h_inv, d_a, N_a) # Assina a mensagem com minha chave
print("\nc_inv =", c_inv.upper())
print("\nsig_h_inv =", hexPrint(sig_h_inv))